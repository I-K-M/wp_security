package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io/ioutil"
	"net/http"
	"strings"
	"time"
)

// WPUser maps the structure of a user returned by WP REST API
type WPUser struct {
	ID   int    `json:"id"`
	Name string `json:"name"`
	Slug string `json:"slug"`
}

// ANSI colour codes for nicer output
var (
	green  = "\033[32m"
	red    = "\033[31m"
	yellow = "\033[33m"
	blue   = "\033[34m"
	reset  = "\033[0m"
)

func main() {
	target := flag.String("url", "", "Target WordPress site (e.g. https://example.com)")
	flag.Parse()

	if *target == "" {
		fmt.Println(red + "❌ Please provide a target with --url" + reset)
		return
	}

	// Normalise URL
	url := strings.TrimRight(*target, "/")

	client := &http.Client{Timeout: 10 * time.Second}

	fmt.Println(blue + "=== WordPress Pentest Tool ===" + reset)
	fmt.Println("Target:", url, "\n")

	// Run all checks
	checkReadme(client, url+"/readme.html")
	checkUsers(client, url+"/wp-json/wp/v2/users")
	checkXMLRPC(client, url+"/xmlrpc.php")
	checkConfig(client, url+"/wp-config.php")
	checkEnvFile(client, url+"/.env")
	checkGitDir(client, url+"/.git/")
	checkUploadsDir(client, url+"/wp-content/uploads/")
	checkHeaders(client, url+"/")
}

func checkReadme(client *http.Client, url string) {
	resp, err := client.Get(url)
	if err != nil {
		fmt.Println(red+"[!] Error readme.html:", err, reset)
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode == 200 {
		body, _ := ioutil.ReadAll(resp.Body)
		if strings.Contains(string(body), "WordPress") {
			fmt.Println(yellow+"[+] readme.html found → version disclosure:", url, reset)
		}
	} else {
		fmt.Println(green+"[-] readme.html not found", reset)
	}
}

func checkUsers(client *http.Client, url string) {
	resp, err := client.Get(url)
	if err != nil {
		fmt.Println(red+"[!] Error REST API users:", err, reset)
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode == 200 {
		var users []WPUser
		if err := json.NewDecoder(resp.Body).Decode(&users); err == nil {
			fmt.Println(yellow + "[+] Users exposed via REST API:" + reset)
			for _, u := range users {
				fmt.Printf("    ID:%d | Name:%s | Slug:%s\n", u.ID, u.Name, u.Slug)
			}
		} else {
			fmt.Println(red + "[?] Could not parse JSON users" + reset)
		}
	} else {
		fmt.Println(green+"[-] REST API users protected", reset)
	}
}

func checkXMLRPC(client *http.Client, url string) {
	resp, err := client.Get(url)
	if err != nil {
		fmt.Println(red+"[!] Error xmlrpc.php:", err, reset)
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode == 405 {
		fmt.Println(yellow + "[+] xmlrpc.php exposed (Method Not Allowed, but endpoint accessible)" + reset)
	} else if resp.StatusCode == 200 {
		fmt.Println(yellow+"[+] xmlrpc.php accessible:", url, reset)
	} else {
		fmt.Println(green+"[-] xmlrpc.php not found", reset)
	}
}

func checkConfig(client *http.Client, url string) {
	resp, err := client.Get(url)
	if err != nil {
		fmt.Println(red+"[!] Error wp-config.php:", err, reset)
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode == 200 {
		fmt.Println(red+"[!!!] wp-config.php downloadable → CRITICAL:"+reset, url)
	} else {
		fmt.Println(green+"[-] wp-config.php protected", reset)
	}
}

func checkEnvFile(client *http.Client, url string) {
	resp, err := client.Get(url)
	if err != nil {
		fmt.Println(red+"[!] Error .env:", err, reset)
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode == 200 {
		fmt.Println(red+"[!!!] .env file accessible → CRITICAL:"+reset, url)
	} else {
		fmt.Println(green+"[-] .env not accessible", reset)
	}
}

func checkGitDir(client *http.Client, url string) {
	resp, err := client.Get(url)
	if err != nil {
		fmt.Println(red+"[!] Error .git:", err, reset)
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode == 200 {
		fmt.Println(red+"[!!!] .git directory accessible → CRITICAL:"+reset, url)
	} else {
		fmt.Println(green+"[-] .git directory protected", reset)
	}
}

func checkUploadsDir(client *http.Client, url string) {
	resp, err := client.Get(url)
	if err != nil {
		fmt.Println(red+"[!] Error uploads dir:", err, reset)
		return
	}
	defer resp.Body.Close()

	if resp.StatusCode == 200 && strings.Contains(strings.ToLower(resp.Header.Get("Content-Type")), "text/html") {
		fmt.Println(yellow+"[+] /uploads/ may have directory listing enabled:"+reset, url)
	} else {
		fmt.Println(green+"[-] uploads dir protected", reset)
	}
}

func checkHeaders(client *http.Client, url string) {
	resp, err := client.Get(url)
	if err != nil {
		fmt.Println(red+"[!] Error headers:", err, reset)
		return
	}
	defer resp.Body.Close()

	headers := resp.Header
	fmt.Println(blue + "\n=== Security Headers Check ===" + reset)

	expected := []string{"X-Frame-Options", "Content-Security-Policy", "X-XSS-Protection", "Strict-Transport-Security"}
	for _, h := range expected {
		if _, ok := headers[h]; ok {
			fmt.Println(green + "[+] " + h + " present" + reset)
		} else {
			fmt.Println(yellow + "[-] " + h + " missing" + reset)
		}
	}
}
